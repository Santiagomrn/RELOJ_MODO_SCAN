#include <stdint.h>
#include "Nokia5110.h"
#include "tm4c1294ncpdt.h"

//****************************************************************
// 			Señal  												(Nokia 5110)						M4C1294NCPDT
//			RESET 											( RST, PIN 1 )							Conectar a PA7
// 			SSI0FSS [Chip enable]						( CE, PIN 2 )							Conectar a PA3
// 			Data/command									( DC, PIN 3 )							Conectar a PA6
// 			SSI0Tx												( Din, PIN 4)							Conectar a PA4
// 			SSI0CLK											( CLK, PIN 5 )								Conectar a PA2
// 			3.3V													( VCC, PIN 6 )								Power
//			No conectado 									(  BL,   PIN 7	), LED				GND
// 			GROUND											( GND, PIN 8 )							GND
//****************************************************************

//se�al					(Nokia 5110)		M4C1294NCPDT
//Reset					(RST, pin 1)			conectar a PA7
//SSI0Fss				(CE,  pin 2)			conectar a PA3
//Data/Command	(DC,  pin 3)			conectar a PA6
//SSI0Tx				(Din, pin 4)			conectar a PA4
//SSI0Clk				(Clk, pin 5)			conectar a PA2
//3.3 v					(Vcc, pin 6)			power
//no conectado	(BL,  pin 7)			luz trasera GND
//Ground				(Gnd, pin 8) 		GND
//******************************************************************
#define LCD_X 84																				// Tamaño Horizontal 
#define LCD_Y	48																			// Tamaño Vertical

#define DC							(*((volatile uint32_t *)0x40058100))		// Enmascar el Bit 6 del PA 
#define DC_COMMAND		0x00														// Valor de Comando			
#define DC_DATA				0X40														//  Valor de Dato
#define RESET					(*((volatile uint32_t *)0x40058200))		// Enmascaramiento de BIT 7 del PA 
#define RESET_LOW		0x00														// Habilitar Reset
#define RESET_HIGH		0X80														// Inhabilitar Reset

//Punteros para el puerto A
// Configuración de Puerto A
#define GPIO_PORTA_DIR_R    (*((volatile uint32_t *)0x40058400))						// Dirección Puerto A * Todos salida
#define GPIO_PORTA_AFSEL_R	(*((volatile uint32_t *)0x40058420))					// Dirección AFSEL Register * Funciones digitales alternativas
#define GPIO_PORTA_DEN_R	  (*((volatile uint32_t *)0x4005851C))						//  Dirección Digital Enable Register
#define GPIO_PORTA_AMSEL_R	(*((volatile uint32_t *)0x40058528))					//  Dirección de Funciones Analógicas
#define GPIO_PORTA_PCTL_R	  (*((volatile uint32_t *)0x4005852C))					//	DIrección del PCTL
	
//Configura modulo SPI cero
#define SSI0_CR0_R        (*((volatile uint32_t *)0x40008000))								//SCR=0, SPH=0, SPO=0, FRF=0, DSS=0x7
#define SSI0_CR1_R        (*((volatile uint32_t *)0x40008004))								//FSSHLDFRM=0, HSCLKEN=0, MODE=0, MS=0, SSE=0, LBM=0
#define SSI0_DR_R         (*((volatile uint32_t *)0x40008008))								// Registro de Datos 
#define SSI0_SR_R         (*((volatile uint32_t *)0x4000800C))								// Registro de Banderas
#define SSI0_CPSR_R       (*((volatile uint32_t *)0x40008010))							//	
#define SSI0_CC_R         (*((volatile uint32_t *)0x40008FC8))								//	

#define SSI_CR0_SCR_M       		0x0000FF00  					//
//#define SSI_CR0_SPH						  0X00000080				// SPH Bit 7
//#define SSI_CR0_SPO						  0X00000040				// SPO Bit 6
#define SSI_CR0_FRF_M           0x00000030  						// SSI Formato FreesScale	
#define SSI_CR0_FRF_MOTO        0x00000000  				// 
#define SSI_CR0_DSS_M           0x0000000F  					// 
#define SSI_CR0_DSS_8           0x00000007  						// Tamaño de QSSI Data	[8 Bits de Datos]
#define SSI_CR1_MS              0x00000004  							// 
#define SSI_CR1_SSE             0x00000002  						// 
																						// 
#define SSI_SR_RNE              0x00000004  							// 
#define SSI_SR_TNF              0x00000002  							//
#define SSI_SR_TFE              0x00000001  							// 
#define SSI_CPSR_CPSDVSR_M      0x000000FF  			// 
#define SSI_CC_CS_M             0x0000000F  						// 
#define SSI_CC_CS_SYSPLL        0x00000000  					//

#define SYSCTL_RCGC1_R          (*((volatile unsigned long *)0x400FE61C))						//RGCGCSSI
#define SYSCTL_RCGC2_R          (*((volatile unsigned long *)0x400FE608))						//RCGCGPIO ; Prev 0x400FE108
#define SYSCTL_RCGC1_SSI0       0x00000001  																// SSI0 Clock Gating Control
#define SYSCTL_RCGC2_GPIOA      0x00000001  																// port A Clock Gating Control SYSCTL_RCGCGPIO_R0 

// Enumeración de Datos
enum typeOfWrite{
  COMMAND,                      	// 0
  DATA                          	 	// 1
	};

void Nokia5110_OutString(char *ptr){
	while(*ptr){
	Nokia5110_OutChar( (unsigned char) *ptr);
		ptr = ptr+1;
	}
}

void static lcdwrite(enum typeOfWrite type, char data){
  if(type == COMMAND){
    DC = DC_COMMAND; 							// Comando = 0 pin 7
  } else{
    DC = DC_DATA; 									// Dato = 1 en Pin 7
  }
  while((SSI0_SR_R&SSI_SR_TFE)==0){};   		// Transmisión (Bandera de FIFO) (Está lleno)
  SSI0_DR_R = data;                     							// Una vez vaciado, se envía dato
  while((SSI0_SR_R&SSI_SR_RNE)==0){};  		//  Bandera de FIFO de Recepción (Se encuentra algo)
  data = SSI0_DR_R;                    							// Se lee el dato que se envío
}

// Inicializa Puertos
// Inicializa SPI

void Nokia5110_Init(void){
  volatile unsigned long delay;
  SYSCTL_RCGC1_R |= SYSCTL_RCGC1_SSI0;  					//	Habilitar el registro de control de SSI
  SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOA;				//	Habilitar el reloj del puerto A
	
	//SYSCTL_RCGCSSI_R |=  SYSCTL_RCGCSSI_R0; 							//SYSCTL_RCGCSSI_R0;								// Habilitar el módulo SSI0
	//SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R0;										//	Habilitar reloj del Puerto A
	
  delay = SYSCTL_RCGC2_R;              									//	
	GPIO_PORTA_DIR_R |= 0xC0;          									// Pines : 6 y 7 como salida
  GPIO_PORTA_AFSEL_R |= 0x1C;     									//	Activar funciones especiales SSI para pines PA2, PA3, PA4 [35,36,37]
  GPIO_PORTA_AFSEL_R &= ~0xC0;   									//	Desactivación de funciones especiales de los pines PA6 y PA7
  GPIO_PORTA_DEN_R |= 0xDC;       										// Activa los pines 2,3,4,6,7 como salidas digitales
  //// PASO 4
  GPIO_PORTA_PCTL_R =   (GPIO_PORTA_PCTL_R&0xFFF000FF)+0x000FFF00;  //0x000FFF00;	//		//(GPIO_PORTA_PCTL_R&0xFFF000FF)+0x00022200;		// MAL // Pág 1808.
																																			// Función especial AFSEL 15 para SSI pines PA2-4
									
  GPIO_PORTA_PCTL_R = (GPIO_PORTA_PCTL_R&0x00FFFFFF)+0x00000000;//0x00FFFFFF;//		//Pag 1808 núm 14 no hay nada. DUDA
  GPIO_PORTA_AMSEL_R &= ~0xDC;          							// ?
	
// PASO 2. Maestro o esclavo
  SSI0_CR1_R &= ~SSI_CR1_SSE;          								//
  SSI0_CR1_R &= ~SSI_CR1_MS;           								//
                                      
  SSI0_CC_R = (SSI0_CC_R&~SSI_CC_CS_M)+SSI_CC_CS_SYSPLL;					//
																																		// NOKIA 4Mbits/s Máx
  SSI0_CPSR_R = (SSI0_CPSR_R&~SSI_CPSR_CPSDVSR_M)+16;						// valor 16 cargado Sysclk / (16*(1+SCR)) 
  SSI0_CR0_R &= ~(SSI_CR0_SCR_M | 
									SSI_CR0_SPH |       																	// Valor a 0?
                  SSI_CR0_SPO);        																					//	Valor a 0?
         
  SSI0_CR0_R = (SSI0_CR0_R&~SSI_CR0_FRF_M)+SSI_CR0_FRF_MOTO;			// Freescale
                                       
  SSI0_CR0_R = (SSI0_CR0_R&~SSI_CR0_DSS_M)+SSI_CR0_DSS_8;					// 8 Bits
  SSI0_CR1_R |= SSI_CR1_SSE;           																// ?

//	Se resetea la LCD a un estado conocido
  RESET = RESET_LOW;                    									//  Colocar reset a 0 
  for(delay=0; delay<10; delay=delay+1);								// Tiempo de espera 100 ns
  RESET = RESET_HIGH;                   									//	Colocar reset a 1

// Hoja de Comandos   

  lcdwrite(COMMAND, 0x21); 			//   
  lcdwrite(COMMAND, 0xB8);        	  	//  
  lcdwrite(COMMAND, 0x04);     		//
  lcdwrite(COMMAND, 0x15);       		//14
  lcdwrite(COMMAND, 0x20);         	//
  lcdwrite(COMMAND, 0x0D);          	//
	
}

// Dirección de Impresión Horizontal
void Nokia5110_OutChar(unsigned char data){
  int i;
  lcdwrite(DATA, 0x00);          						// Espacio en blanco       
  for(i=0; i<5; i=i+1){
    lcdwrite(DATA, ASCII[data - 0x20][i]);			// Letra obtenida de la tabla
  }
  lcdwrite(DATA, 0x00);                					// Espacio en blanco
}

//****************************************************************************
char UADY[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x60, 0x30, 0x50, 0x48, 0x0C, 0x3C, 0xDC, 0x2A, 0x4E, 0x37, 0x72, 0x56, 0x64, 0x1C, 0x10, 0x08, 0x18, 0x30, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x20, 0xE0, 0x60, 0x48, 0x6C, 0xCC, 0x6D, 0xED, 0x29, 0xEF, 0xCB, 0xEA, 0xEA, 0x08, 0xE8, 0xE8, 0xE8, 0xEB, 0xAB, 0xE9, 0xED, 0xEF, 0xE9, 0x88, 0xE8, 0xE8, 0x28, 0xCA, 0xEB, 0xAB, 0xEB, 0xED, 0x2D, 0x6C, 0xCC, 0x4C, 0x78, 0x60, 0xE0, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0xC7, 0x60, 0xF0, 0xEB, 0xD3, 0xFB, 0x03, 0xFC, 0x99, 0x54, 0x9F, 0x77, 0x3B, 0x9E, 0xCE, 0x59, 0x7F, 0x2F, 0xEB, 0x6E, 0xAD, 0x58, 0xDD, 0x0E, 0xBE, 0xBA, 0x65, 0xDF, 0x54, 0x85, 0xFD, 0x03, 0x0A, 0xD3, 0xEA, 0xD0, 0xF0, 0xC7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xF0, 0x98, 0xF8, 0xEE, 0xDF, 0x98, 0xD8, 0xDB, 0x98, 0xDF, 0xAD, 0x71, 0xCE, 0x9E, 0x9F, 0x1F, 0x1F, 0x5A, 0xD7, 0xD3, 0xDF, 0x5B, 0x57, 0x1E, 0x19, 0x1F, 0x1F, 0x9F, 0xA7, 0xC3, 0x53, 0xB1, 0xDF, 0x1C, 0xD8, 0xDA, 0x9C, 0xD8, 0x4E, 0xB8, 0x50, 0xF1, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0E, 0x0F, 0x0A, 0x17, 0x3B, 0x20, 0x30, 0x6F, 0x79, 0xD0, 0x9E, 0xD1, 0xFF, 0xA5, 0xAF, 0xAB, 0x0E, 0xD8, 0x58, 0x18, 0xD8, 0xFE, 0x8A, 0xBF, 0xBE, 0x83, 0xC6, 0xDF, 0xBF, 0x64, 0x6F, 0x50, 0x37, 0x3C, 0x39, 0x1D, 0x0E, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0C, 0x0F, 0x1B, 0x1F, 0x1F, 0x1C, 0x18, 0x9F, 0xFF, 0x39, 0xFF, 0x1B, 0x18, 0x1D, 0x1E, 0x0D, 0x0B, 0x0E, 0x0C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const unsigned char alex[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xC0, 0x81, 0x1F, 0x7E, 0xC0, 0x9F, 0x20, 0x43, 0xBC, 0x78, 0x70, 0xD8, 0x80, 0x00, 0x81, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xF3, 0xC7, 0x0C, 0x38, 0x73, 0x4F, 0x18, 0x72, 0x47, 0x9E, 0xFC, 0xFC, 0xF5, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF2, 0x70, 0x78, 0x78, 0x70, 0x78, 0x38, 0x38, 0xFC, 0xFC, 0xFE, 0xDF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8, 0xE0, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x83, 0x21, 0x11, 0x40, 0xF8, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xBF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xF1, 0xE0, 0xC0, 0xC0, 0xC0, 0xA0, 0x60, 0x60, 0x40, 0xE0, 0xFF, 0xC0, 0xC0, 0xC1, 0xC1, 0xC1, 0xCB, 0xC1, 0xFF, 0xF3, 0xFF, 0x7F, 0x3F, 0x07, 0x07, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF8, 0xF0, 0xD0, 0xA0, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x1F, 0x60, 0x80, 0x00, 0x00, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0x83, 0x07, 0x07, 0x07, 0x01, 0x00, 0x00, 0xC1, 0xC1, 0x77, 0x1F, 0x0F, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x48, 0xE9, 0xF9, 0xFF, 0xFB, 0xFF, 0xF9, 0xF8, 0xF8, 0xF8, 0xF0, 0xF8, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFC, 0xFC, 0x79, 0x39, 0x8A, 0x82, 0x74, 0x34, 0x85, 0x47, 0x27, 0x87, 0xE7, 0x77, 0x0E, 0x1E, 0x2C, 0x3C, 0x3C, 0x18, 0x38, 0x30, 0x30, 0x30, 0x30, 0x60, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xD0, 0xE0, 0xE0, 0xE0, 0xF6, 0xBF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x1F, 0x1F, 0x0F, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7A, 0x00, 0x8F, 0xFF, 0xF1, 0x08, 0xBF, 0xC1, 0x7C, 0x1F, 0x0F, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x01, 0x03, 0x03, 0x07, 0x07, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };  

//****************************************************************************
void LcdBitmap(char my_array[]){
  for (int index = 0 ; index < (LCD_X * LCD_Y / 8) ; index++)
    lcdwrite(DC_DATA, my_array[index]);
}

void LcdClear(void){
  for (int index = 0 ; index < (LCD_X * LCD_Y / 8) ; index++)
    lcdwrite(DC_DATA, 0x00);
}

void mostrar_hora_t(int horas,int minutos,int segundos){
	LcdClear();
	lcdwrite(COMMAND,0X80+14);            //Ubicamos el cursor el columna 14
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	int h1,h2,m1,m2,s1,s2;
	unsigned char hora[]="00:00:00";
	h1=horas/10;
	h2=horas%10;
	m1=minutos/10;
	m2=minutos%10;
	s1=segundos/10;
	s2=segundos%10;
	
	hora[0]=h1+0x30;
	hora[1]=h2+0x30;
	hora[3]=m1+0x30;
	hora[4]=m2+0x30;
	hora[6]=s1+0x30;
	hora[7]=s2+0x30;
	
	Nokia5110_OutString(hora);
}
//
void portN_Init(){
	SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R12; // Se enciende Puerto N
	while ( ( SYSCTL_PRGPIO_R & SYSCTL_RCGCGPIO_R12 ) == 0 ){}; // verificar Encendido del Puerto
	GPIO_PORTN_DIR_R = 0x03; // Puerto N0 y N1 -> 0011 como SALIDA -> 0111 
	GPIO_PORTN_DEN_R = 0x03; // Puerto como entrada Digital (ambos pines)
	GPIO_PORTN_AFSEL_R &= ~0x03;
	GPIO_PORTN_PCTL_R = ~0x03;
	GPIO_PORTN_AMSEL_R = ~0x0F;
}
//
void PortN_Output(uint32_t data){
	GPIO_PORTN_DATA_R = data;
}
//
void HIB_Init(void)
{

	SYSCTL_RCGCHIB_R |= SYSCTL_RCGCHIB_R0; //Modulo de hibernacion
	while ((SYSCTL_PRHIB_R & SYSCTL_PRHIB_R0) == 0)
	{
	};							  //Verificaci?n que est? activo
	HIB_CTL_R |= HIB_CTL_CLK32EN; //activa reloj del inver
	while ((HIB_CTL_R & HIB_CTL_WRC) == 0)
	{
	};							//Verificaci?n de la escritura del modulo
	HIB_CTL_R |= HIB_CTL_RTCEN; //Activacion del reloj y calendario
	HIB_CC_R = HIB_CC_SYSCLKEN; //Activa el sistema de reloj
}

void RTCCLK_PK7_Init(void)
{
	SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R9; //Habilitacion del puerto K
	while ((SYSCTL_PRGPIO_R & SYSCTL_PRGPIO_R9) == 0)
	{
	};							//Verificacion del encendido
	GPIO_PORTK_DIR_R |= 0x81;	//Selecion de Salidas
	GPIO_PORTK_AFSEL_R |= 0x80; // Activacion de funciones alternativas en PK7
	GPIO_PORTK_DEN_R |= 0x81;	//Activacion de I/O digitales en PK0 y pk7
	GPIO_PORTK_PCTL_R = (GPIO_PORTK_PCTL_R & 0X0FFFFFFF) + 0x50000000;
	GPIO_PORTK_AMSEL_R = 0x00; // Deshabilitacion funcionalidad analogica
}

void T0CCP0_PL4_Init(void)
{
	SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R10; //Habilitacion del puerto K
	while ((SYSCTL_PRGPIO_R & SYSCTL_PRGPIO_R10) == 0)
	{
	};							//Verificacion del encendido
	GPIO_PORTL_DIR_R &= 0xEF;	//Seleccion de entrada
	GPIO_PORTL_AFSEL_R |= 0x10; // Activacion de funciones alternativas en PL4
	GPIO_PORTL_DEN_R = 0x10;	//Activacion de I/O digitales en PL4

	GPIO_PORTL_PCTL_R = (GPIO_PORTL_PCTL_R & 0XFFF0FFFF) + 0x00030000;
	GPIO_PORTL_AMSEL_R = 0x00; // Deshabilitacion funcionalidad analogica
}
void mostrar_horas(int horas){
	int h1,h2;
	unsigned char hora[]="  ";
	lcdwrite(COMMAND,0X80+14);            //Ubicamos el cursor el columna 14
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	
	h1=horas/10;
	h2=horas%10;
	hora[0]=h1+0x30;
	hora[1]=h2+0x30;
	Nokia5110_OutString(hora);
}

void mostrar_minutos(int minutos){
	int m1,m2;
	unsigned char hora[]="  ";
	lcdwrite(COMMAND,0X80+35);            //Ubicamos el cursor el columna 35
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	
	m1=minutos/10;
	m2=minutos%10;
	hora[0]=m1+0x30;
	hora[1]=m2+0x30;
	Nokia5110_OutString(hora);
}

void mostrar_segundos(int segundos){
  int s1,s2;
	unsigned char hora[]="  ";
	lcdwrite(COMMAND,0X80+56);            //Ubicamos el cursor el columna 56
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	s1=segundos/10;
	s2=segundos%10;
	hora[0]=s1+0x30;
	hora[1]=s2+0x30;
	Nokia5110_OutString(hora);
}	
void inicializar_mostrar_hora(void){
	LcdClear();
	lcdwrite(COMMAND,0X80+14);            //Ubicamos el cursor el columna 14
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	unsigned char hora[]="00:00:00";

	Nokia5110_OutString(hora);
}

void limpiar_horas(void){
	lcdwrite(COMMAND,0X80+14);            //Ubicamos el cursor el columna 14
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	Nokia5110_OutString("  ");
}

void limpiar_minutos(void){
	lcdwrite(COMMAND,0X80+35);            //Ubicamos el cursor el columna 35
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	Nokia5110_OutString("  ");
}

void limpiar_segundos(void){
	lcdwrite(COMMAND,0X80+56);            //Ubicamos el cursor el columna 56
	lcdwrite(COMMAND,0X40+2);            //Ubicamos el cursor el fila 16
	Nokia5110_OutString("  ");
}
void Timer0A_Init(void)
{											   //Modo Real Time Clock
	SYSCTL_RCGCTIMER_R |= SYSCTL_RCGCTIMER_R0; //activa el reloj de timer 0
	while ((SYSCTL_PRTIMER_R & SYSCTL_RCGCTIMER_R0) == 0)
	{
	}; //verifica la habilitacion del timer0

	TIMER0_CTL_R &= ~TIMER_CTL_TAEN; //Apaga el timer
	TIMER0_TAMR_R = 0;
	TIMER0_CFG_R |= TIMER_CFG_32_BIT_RTC; //Configura para 32 bits en RTC
	TIMER0_TAMATCHR_R = 0X0000;			  //Configura valor de coincidencia
	TIMER0_TBMATCHR_R = 0X0000;

	TIMER0_ICR_R |= TIMER_ICR_RTCCINT; //Input Clear Registro
	TIMER0_IMR_R |= TIMER_IMR_RTCIM;   //Mascara de interrupcion

	NVIC_PRI4_R = (NVIC_PRI4_R & 0X0FFFFFFF) | 0X80000000; //prioridad 2
	NVIC_EN0_R |= 1 << 19;
	// Para el debugger
	// No se requieren interrupciones
	TIMER0_CTL_R |= TIMER_CTL_TAEN; //Activacion del timer
}

//


